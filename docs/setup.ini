# ============================================================================
# FILE: pyproject.toml
# ============================================================================
"""
ğŸ¯ WHAT IS THIS FILE?
Think of it like package.json in Node.js or pom.xml in Java.
It lists ALL the libraries your project needs.

ğŸ” WHY NOT requirements.txt?
requirements.txt is like a shopping list.
pyproject.toml is like a recipe book (includes versions, configs, etc.)

ğŸ“¦ EVERY DEPENDENCY EXPLAINED:
"""

[project]
name = "fastapi-tutorial"
version = "1.0.0"
description = "Production-grade FastAPI backend from scratch"
requires-python = ">=3.11"

dependencies = [
    # === WEB FRAMEWORK ===
    "fastapi>=0.109.0",
    # WHY: Modern Python web framework
    # WHAT IF I DON'T: Have to use older frameworks (Django, Flask)
    # BENEFIT: Auto-generates API docs, async support, type safety
    
    "uvicorn[standard]>=0.27.0",
    # WHY: ASGI server (runs your FastAPI app)
    # WHAT IF I DON'T: Your code won't run! (like Node.js needs 'node')
    # BENEFIT: High performance, WebSocket support
    
    # === DATABASE ===
    "sqlalchemy>=2.0.25",
    # WHY: ORM (Object-Relational Mapper) - talk to databases with Python
    # WHAT IF I DON'T: Write raw SQL everywhere (error-prone, hard to maintain)
    # BENEFIT: Type safety, migrations, multiple database support
    
    "asyncpg>=0.29.0",
    # WHY: Async PostgreSQL driver (FAST!)
    # WHAT IF I DON'T: Use psycopg2 (10x slower, blocks threads)
    # BENEFIT: Non-blocking DB queries = handle 1000s of users
    
    "alembic>=1.13.1",
    # WHY: Database migrations (version control for your DB schema)
    # WHAT IF I DON'T: Manually ALTER TABLE in production (scary!)
    # BENEFIT: Rollback changes, track history, team collaboration
    
    # === DATA VALIDATION ===
    "pydantic>=2.5.3",
    # WHY: Validate incoming data automatically
    # WHAT IF I DON'T: Manual validation = bugs, security holes
    # BENEFIT: Type safety, auto API docs, conversion
    
    "pydantic-settings>=2.1.0",
    # WHY: Manage config from environment variables
    # WHAT IF I DON'T: Hardcode passwords, API keys (DANGEROUS!)
    # BENEFIT: Different configs for dev/staging/prod
    
    # === SECURITY ===
    "python-jose[cryptography]>=3.3.0",
    # WHY: Create and verify JWT tokens (authentication)
    # WHAT IF I DON'T: Can't implement secure login
    # BENEFIT: Industry standard, stateless auth
    
    "passlib[bcrypt]>=1.7.4",
    # WHY: Hash passwords (NEVER store plain text!)
    # WHAT IF I DON'T: One database leak = all passwords stolen
    # BENEFIT: Bcrypt is slow = hard to crack
    
    "python-multipart>=0.0.6",
    # WHY: Handle file uploads
    # WHAT IF I DON'T: Can't accept images, documents
    
    # === HTTP CLIENT ===
    "httpx>=0.26.0",
    # WHY: Make HTTP requests to external APIs (Google OAuth, etc.)
    # WHAT IF I DON'T: Can't integrate with third-party services
    # BENEFIT: Async support, better than 'requests'
    
    # === BACKGROUND TASKS ===
    "celery>=5.3.4",
    # WHY: Run tasks in background (send emails, generate reports)
    # WHAT IF I DON'T: Users wait 5 seconds for email to send
    # BENEFIT: Better UX, horizontal scaling
    
    "redis>=5.0.1",
    # WHY: Message broker for Celery + caching
    # WHAT IF I DON'T: No background tasks, slower responses
    # BENEFIT: In-memory = super fast (sub-millisecond)
    
    # === LOGGING ===
    "structlog>=24.1.0",
    # WHY: Better logs (JSON format, searchable)
    # WHAT IF I DON'T: Can't debug production issues
    # BENEFIT: Integrate with ELK, Datadog, etc.
]

"""
ğŸ“ JUNIOR DEV QUESTION: "Why so many dependencies?"

ANSWER: Each solves ONE problem well. It's like:
- FastAPI = The restaurant kitchen
- SQLAlchemy = The refrigerator (stores data)
- Celery = The delivery driver (background tasks)
- Redis = The notepad (quick memory)
- Pydantic = The health inspector (validates everything)

Trying to build all this yourself = 6 months of work + bugs!
"""


# ============================================================================
# STEP 2: CONFIGURATION MANAGEMENT
# ============================================================================
"""
ğŸ¤” WHY THIS MATTERS:
Hardcoded config = Security nightmare
Environment-based config = Secure, flexible

ğŸ“– WHAT YOU'LL LEARN:
1. Why never commit passwords to Git
2. How to use .env files
3. What are environment variables
"""

# FILE: .env.example
"""
ğŸ¯ WHAT IS THIS?
Template for environment variables. Developers copy this to .env

âŒ WRONG WAY:
# In your code:
DATABASE_URL = "postgresql://admin:secret123@prod-db:5432/myapp"
# Problems:
# 1. Password in Git (anyone can see)
# 2. Can't change without code deploy
# 3. Same config for dev/prod (dangerous!)

âœ… RIGHT WAY:
# In .env file (NOT committed to Git):
DATABASE_URL=postgresql://user:pass@localhost:5432/dev_db

# In production server:
DATABASE_URL=postgresql://admin:secret@prod-db:5432/prod_db
"""

# Database
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/dbname

# JWT Secret (CRITICAL!)
SECRET_KEY=your-secret-key-min-32-chars  # Generate: openssl rand -hex 32

# Application
DEBUG=true  # Never true in production!
LOG_LEVEL=DEBUG  # Production: INFO or WARNING

# API
ALLOWED_ORIGINS=http://localhost:3000  # Your frontend URL

"""
ğŸ“ JUNIOR DEV QUESTION: "What is SECRET_KEY used for?"

ANSWER: JWT tokens are signed with this key.
- If someone steals your SECRET_KEY = They can create fake login tokens
- It's like the key to your house
- NEVER share it, NEVER commit to Git
- Change it = All existing tokens become invalid

GENERATING SECURE KEY:
$ openssl rand -hex 32
Output: 8f42a73054b12e9e8e6d8c5a4e8f7a9b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
"""


# ============================================================================
# FILE: app/core/config.py
# ============================================================================
"""
ğŸ¯ WHAT IS THIS?
Central place for ALL configuration.
Think of it as your app's "settings menu"

ğŸ” WHY NOT just use os.getenv() everywhere?
- Type safety (validates types automatically)
- Default values
- Single source of truth
- Auto-completion in IDE
"""

from pydantic_settings import BaseSettings
from pydantic import Field, field_validator
from typing import List

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    
    ğŸ“ HOW IT WORKS:
    1. Looks for .env file
    2. Loads environment variables
    3. Validates types
    4. Provides defaults
    """
    
    # Database
    database_url: str = Field(
        default="postgresql+asyncpg://user:password@localhost:5432/dbname",
        description="PostgreSQL connection string"
    )
    """
    ğŸ“ EXPLANATION:
    - `str` = Must be a string (Pydantic validates this)
    - `Field()` = Adds metadata and default value
    - If DATABASE_URL env var exists, it overrides the default
    
    ğŸŒ CONNECTION STRING ANATOMY:
    postgresql+asyncpg://user:password@localhost:5432/dbname
    â”‚                    â”‚    â”‚        â”‚         â”‚    â”‚
    â”‚                    â”‚    â”‚        â”‚         â”‚    â””â”€ Database name
    â”‚                    â”‚    â”‚        â”‚         â””â”€â”€â”€â”€â”€â”€ Port
    â”‚                    â”‚    â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Host
    â”‚                    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Password
    â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Username
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Driver
    """
    
    # Application
    app_name: str = Field(default="FastAPI Tutorial")
    debug: bool = Field(default=False)
    """
    ğŸš¨ CRITICAL: debug=True in production = SECURITY RISK!
    Why? Shows:
    - Stack traces (reveal code structure)
    - Database queries
    - Environment variables
    
    âœ… RULE: Always False in production!
    """
    
    # JWT Authentication
    secret_key: str = Field(..., min_length=32)
    """
    ğŸ“ EXPLANATION:
    - `...` = REQUIRED (no default)
    - `min_length=32` = Must be at least 32 characters
    - If SECRET_KEY not set = App crashes on startup (intentional!)
    
    WHY CRASH? Better to fail early than run with weak security!
    """
    
    algorithm: str = Field(default="HS256")
    """
    ğŸ” JWT SIGNING ALGORITHMS:
    - HS256: Symmetric (same key signs & verifies) - FAST
    - RS256: Asymmetric (public/private keys) - MORE SECURE
    
    When to use RS256? Microservices (one signs, many verify)
    """
    
    access_token_expire_minutes: int = Field(default=30)
    """
    ğŸ¤” WHY 30 MINUTES?
    - Too short (5 min) = Users re-login constantly (bad UX)
    - Too long (24 hours) = If stolen, attacker has access all day
    - 30 min = Good balance
    
    ğŸ’¡ PRO TIP: Short access token + long refresh token = Best of both worlds
    """
    
    # CORS (Cross-Origin Resource Sharing)
    allowed_origins: List[str] = Field(default=["http://localhost:3000"])
    """
    ğŸŒ WHAT IS CORS?
    Browser security that prevents:
    evil.com from calling api.yourapp.com
    
    ğŸ“ EXAMPLE:
    Your frontend: http://localhost:3000 (React app)
    Your backend: http://localhost:8000 (FastAPI)
    
    Without CORS config = Browser blocks requests!
    
    allowed_origins tells browser: "These domains are okay"
    """
    
    @field_validator("allowed_origins", mode="before")
    @classmethod
    def parse_cors_origins(cls, v):
        """
        ğŸ¯ WHAT DOES THIS DO?
        Converts comma-separated string to list
        
        Environment variable: ALLOWED_ORIGINS=http://localhost:3000,https://prod.com
        Python gets: ["http://localhost:3000", "https://prod.com"]
        """
        if isinstance(v, str):
            return [origin.strip() for origin in v.split(",")]
        return v
    
    class Config:
        env_file = ".env"  # Load from .env file
        case_sensitive = False  # DATABASE_URL = database_url

settings = Settings()
"""
ğŸ“ SINGLETON PATTERN:
Create settings once, use everywhere.
Why? Don't re-read .env file on every import (slow!)
"""


# ============================================================================
# STEP 3: DATABASE ARCHITECTURE (The Most Important Part!)
# ============================================================================
"""
ğŸ¤” WHY THIS MATTERS:
Bad database setup = App crashes under load
Good database setup = Handles millions of users

ğŸ“– WHAT YOU'LL LEARN:
1. Sync vs Async databases (critical!)
2. Connection pooling
3. Session management
4. ORM basics
"""

# FILE: app/core/database.py

from sqlalchemy.ext.asyncio import (
    AsyncSession,
    AsyncEngine,
    create_async_engine,
    async_sessionmaker
)
from sqlalchemy.orm import DeclarativeBase

"""
ğŸ“ SYNC VS ASYNC - THE MOST IMPORTANT CONCEPT!

âŒ SYNCHRONOUS (Old way):
def get_user(user_id):
    result = db.query(User).get(user_id)  # â¸ï¸ Waits here (blocks thread)
    return result

Problem: While waiting for database, thread does NOTHING
- 1 thread = 1 user at a time
- 100 threads = 100 users max
- Threads are expensive (8MB each!)

âœ… ASYNCHRONOUS (Modern way):
async def get_user(user_id):
    result = await db.query(User).get(user_id)  # ğŸ”„ Releases thread while waiting
    return result

Magic: While waiting for database, thread handles OTHER users
- 1 thread = 1000s of users
- Much cheaper
- Much faster

ğŸ“Š REAL NUMBERS:
Synchronous: 500 requests/second
Asynchronous: 5000 requests/second (10x improvement!)
"""


class Base(DeclarativeBase):
    """
    ğŸ¯ WHAT IS THIS?
    Base class for all database models.
    Think of it as the "blueprint template" for tables.
    
    Every model (User, Post, Comment) inherits from this.
    """
    pass


class DatabaseManager:
    """
    ğŸ¯ WHAT IS THIS?
    Manages database connections.
    Think of it as the "connection pool manager"
    
    ğŸ¤” WHY A CLASS?
    - Encapsulation (hide complexity)
    - Single responsibility
    - Easy to test
    - Reusable
    """
    
    def __init__(self, database_url: str):
        """
        ğŸ“ CONNECTION POOLING EXPLAINED:
        
        âŒ WITHOUT POOL:
        Every request:
        1. Connect to database (50ms)
        2. Execute query (10ms)
        3. Disconnect (20ms)
        Total: 80ms (most time wasted!)
        
        âœ… WITH POOL:
        Startup:
        - Create 10 connections
        - Keep them open and ready
        
        Every request:
        1. Borrow connection from pool (instant)
        2. Execute query (10ms)
        3. Return connection to pool
        Total: 10ms (8x faster!)
        """
        
        self.engine: AsyncEngine = create_async_engine(
            database_url,
            echo=settings.debug,  # Show SQL queries in console (dev only!)
            pool_pre_ping=True,   # Test connection before using
            pool_size=10,         # Keep 10 connections ready
            max_overflow=20       # Allow 20 more under load
        )
        """
        ğŸ“ PARAMETER BREAKDOWN:
        
        echo=settings.debug:
        - Prints all SQL queries to console
        - Helpful in development (see what SQLAlchemy generates)
        - Turn OFF in production (too much noise)
        
        pool_pre_ping=True:
        - Tests connection before using it
        - Prevents "connection lost" errors
        - Adds 1ms overhead but worth it!
        
        pool_size=10:
        - Normal load: 10 connections
        - Why 10? Typical: 5-10 requests/second per instance
        - Each request holds connection for ~100ms
        
        max_overflow=20:
        - Traffic spike? Create up to 20 MORE connections
        - Total max: 30 connections
        - After spike, extra connections close automatically
        
        ğŸ“ JUNIOR DEV QUESTION: "What if I get 100 requests at once?"
        
        ANSWER:
        - Requests 1-10: Use pooled connections (instant)
        - Requests 11-30: Create overflow connections (200ms delay)
        - Requests 31-100: WAIT in queue until connection frees up
        
        This is GOOD! Database has limits. Better to queue than crash.
        """
        
        self.session_factory = async_sessionmaker(
            self.engine,
            class_=AsyncSession,
            expire_on_commit=False,  # Don't expire objects after commit
            autocommit=False,        # Manual transaction control
            autoflush=False          # Manual flush control
        )
        """
        ğŸ“ SESSION FACTORY EXPLAINED:
        
        Think of a session as a "shopping cart" for database operations:
        1. Add items to cart (INSERT/UPDATE/DELETE)
        2. Review cart (nothing saved yet)
        3. Checkout (COMMIT - saves everything)
        4. Cancel order (ROLLBACK - discard everything)
        
        expire_on_commit=False:
        - After commit, can still access object attributes
        - Without this: accessing user.email after commit = extra query!
        
        autocommit=False:
        - WE control when to commit
        - Allows grouping operations (all-or-nothing)
        
        autoflush=False:
        - WE control when to flush (send SQL to DB)
        - Better performance (batch operations)
        """
    
    async def get_session(self):
        """
        ğŸ¯ WHAT IS THIS?
        Provides a database session with automatic cleanup.
        
        ğŸ“ PYTHON GENERATORS & CONTEXT MANAGERS:
        The `yield` keyword makes this a generator.
        FastAPI uses it like a context manager (with statement)
        """
        async with self.session_factory() as session:
            try:
                yield session
                await session.commit()
                """
                ğŸ“ AUTO-COMMIT PATTERN:
                If code succeeds â†’ commit (save changes)
                If exception â†’ rollback (undo changes)
                
                Example:
                - Create user âœ…
                - Send email âŒ (fails)
                - Rollback â†’ user not created (good!)
                """
            except Exception:
                await session.rollback()
                raise
            finally:
                await session.close()
                """
                ğŸ“ FINALLY BLOCK:
                Runs no matter what (success or error)
                - Closes session
                - Returns connection to pool
                - Prevents connection leaks
                """
    
    async def close(self):
        """Close all database connections on shutdown."""
        await self.engine.dispose()


# Global instance
db_manager = DatabaseManager(str(settings.database_url))


async def get_db():
    """
    ğŸ¯ FASTAPI DEPENDENCY INJECTION:
    This function is used in route handlers like:
    
    @router.get("/users")
    async def get_users(db: AsyncSession = Depends(get_db)):
        # db is automatically provided by FastAPI
        pass
    
    ğŸ“ WHY THIS PATTERN?
    1. Automatic session management (no manual open/close)
    2. Easy to test (mock the dependency)
    3. Clean code (no boilerplate in every route)
    """
    async for session in db_manager.get_session():
        yield session


# ============================================================================
# STEP 4: DATABASE MODELS (Your Data Structure)
# ============================================================================
"""
ğŸ¤” WHY THIS MATTERS:
Models define your database schema.
Bad models = Performance issues, can't scale
Good models = Fast queries, easy to extend

ğŸ“– WHAT YOU'LL LEARN:
1. How to define tables with SQLAlchemy
2. Data types and why they matter
3. Indexes (the secret to fast queries)
4. Relationships between tables
"""

# FILE: app/models/user.py

from datetime import datetime
from typing import Optional
from sqlalchemy import String, DateTime, Boolean, func
from sqlalchemy.orm import Mapped, mapped_column

class User(Base):
    """
    ğŸ¯ WHAT IS THIS?
    Python class that represents a database table.
    
    ğŸ—„ï¸ THIS CREATES:
    CREATE TABLE users (
        id SERIAL PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        username VARCHAR(100) UNIQUE NOT NULL,
        ...
    );
    """
    
    __tablename__ = "users"
    
    # Primary Key
    id: Mapped[int] = mapped_column(primary_key=True, index=True)
    """
    ğŸ“ PRIMARY KEY EXPLAINED:
    - Unique identifier for each row
    - Auto-increments: 1, 2, 3, 4, ...
    - index=True = Create index (faster lookups)
    
    ğŸ¤” WHAT IS AN INDEX?
    Think of it like a book index:
    - Without index: Read entire book to find "Python" (slow!)
    - With index: Look at index, jump to page 142 (fast!)
    
    Database:
    - Without index: Scan all 1M users (1 second)
    - With index: Find user in 0.001 seconds (1000x faster!)
    """
    
    # Authentication Fields
    email: Mapped[str] = mapped_column(
        String(255),
        unique=True,
        index=True,
        nullable=False
    )
    """
    ğŸ“ FIELD ATTRIBUTES:
    
    String(255):
    - Max 255 characters
    - Why not unlimited? Indexing requires size limit
    - 255 is standard (fits in single database block)
    
    unique=True:
    - Database enforces uniqueness
    - Two users CAN'T have same email
    - Attempt to insert duplicate = Error (good!)
    
    index=True:
    - Create index on email column
    - WHY? Login queries: WHERE email = 'user@example.com'
    - Without index: Scan millions of rows
    - With index: Instant lookup
    
    nullable=False:
    - Email is REQUIRED
    - Can't be NULL/None
    - Database enforces this
    """
    
    username: Mapped[str] = mapped_column(
        String(100),
        unique=True,
        index=True,
        nullable=False
    )
    
    hashed_password: Mapped[Optional[str]] = mapped_column(
        String(255),
        nullable=True
    )
    """
    ğŸš¨ SECURITY CRITICAL!
    
    âŒ NEVER STORE:
    password: str = "mypassword123"
    
    âœ… ALWAYS STORE:
    hashed_password: str = "$2b$12$KIX..."
    
    ğŸ“ WHY Optional[str]?
    - OAuth users don't have passwords!
    - They login via Google/GitHub
    - nullable=True allows NULL
    
    ğŸ” PASSWORD HASHING:
    Plain: "password123"
    â†“ Bcrypt
    Hash: "$2b$12$KIXm1Z..."
    
    - Same password = DIFFERENT hash each time (salt)
    - Hash â†’ Plain: IMPOSSIBLE (one-way function)
    - Attacker steals database = Can't reverse hashes
    """
    
    # Status Fields
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    """
    ğŸ“ USE CASE:
    - Ban user: SET is_active = false
    - User still in database (audit trail)
    - Can't login (check in authentication)
    """
    
    is_superuser: Mapped[bool] = mapped_column(Boolean, default=False)
    """
    ğŸ“ ROLE-BASED ACCESS CONTROL (RBAC):
    - Superuser = Admin (can do anything)
    - Regular user = Limited permissions
    
    Example:
    @router.delete("/users/{id}")
    async def delete_user(current_user: User = Depends(get_current_user)):
        if not current_user.is_superuser:
            raise HTTPException(403, "Not authorized")
    """
    
    is_verified: Mapped[bool] = mapped_column(Boolean, default=False)
    """
    ğŸ“ EMAIL VERIFICATION FLOW:
    1. User registers â†’ is_verified = False
    2. Send email with verification link
    3. User clicks link â†’ is_verified = True
    4. Only verified users can post/comment
    """
    
    # OAuth Fields
    oauth_provider: Mapped[Optional[str]] = mapped_column(String(50))
    oauth_id: Mapped[Optional[str]] = mapped_column(String(255), index=True)
    """
    ğŸ“ OAUTH AUTHENTICATION:
    
    Regular signup:
    - oauth_provider = NULL
    - oauth_id = NULL
    - has hashed_password
    
    Google signup:
    - oauth_provider = "google"
    - oauth_id = "108234567890123456789" (Google's user ID)
    - hashed_password = NULL
    
    ğŸ” FINDING OAUTH USERS:
    SELECT * FROM users 
    WHERE oauth_provider = 'google' 
    AND oauth_id = '108234567890123456789'
    
    Why index on oauth_id? Fast OAuth lookups!
    """
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now()
    )
    """
    ğŸ“ TIMESTAMPS EXPLAINED:
    
    âŒ WRONG (Python sets time):
    created_at = datetime.utcnow()
    Problem: Different servers = different times (clock drift)
    
    âœ… RIGHT (Database sets time):
    server_default=func.now()
    Benefit: Single source of truth (database clock)
    
    DateTime(timezone=True):
    - Stores as UTC
    - Converts to user's timezone on display
    - No "daylight savings" bugs!
    """
    
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now()
    )
    """
    ğŸ“ AUTO-UPDATE:
    Every time row is updated, updated_at changes automatically.
    
    Example:
    user.email = "new@example.com"
    db.commit()
    # updated_at automatically set to current time!
    """
    
    last_login: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    """
    ğŸ“ USE CASES:
    1. Security: Detect suspicious activity
       "Last login from New York, now login from China in 5 minutes?"
    
    2. Cleanup: Delete users inactive for 90 days
       WHERE last_login < NOW() - INTERVAL '90 days'
    
    3. Analytics: Active user count
       WHERE last_login > NOW() - INTERVAL '30 days'
    """


# ============================================================================
# STEP 5: PYDANTIC SCHEMAS (Data Validation)
# ============================================================================
"""
ğŸ¤” WHY THIS MATTERS:
Users send garbage data. Without validation = database corruption, security holes
With validation = Clean data, automatic API docs, type safety

ğŸ“– WHAT YOU'LL LEARN:
1. Why separate models from schemas
2. Input validation
3. Response serialization
4. Type safety
"""

# FILE: app/schemas/user.py

from pydantic import BaseModel, EmailStr, Field, ConfigDict
from datetime import datetime
from typing import Optional

"""
ğŸ“ MODELS VS SCHEMAS - CRITICAL DISTINCTION!

DATABASE MODEL (SQLAlchemy):
- Represents database table
- Has database-specific stuff (indexes, constraints)
- Used internally

SCHEMA (Pydantic):
- Represents API input/output
- Validates user input
- Generates API documentation
- Used at API boundary

EXAMPLE:
User model: Has hashed_password (internal)
UserResponse schema: NO password field (never expose!)
"""

class UserBase(BaseModel):
    """
    ğŸ¯ BASE SCHEMA:
    Common fields shared by multiple schemas.
    Follows DRY principle (Don't Repeat Yourself)
    """
    
    email: EmailStr = Field(..., description="User email address")
    """
    ğŸ“ EmailStr EXPLAINED:
    
    Regular string: "not-an-email" âœ… Accepted (BAD!)
    EmailStr: "not-an-email" âŒ Rejected automatically
    
    Validates:
    - Has @ symbol
    - Has domain
    - Proper format
    
    ğŸ¤” WHAT IS Field(...)?
    - `...` means REQUIRED (no default)
    - description: Shows in API docs
    - Can add: min_length, max_length, regex, etc.
    """
    
    username: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Unique username"
    )
    """
    ğŸ“ VALIDATION RULES:
    - Must be 3-100 characters
    - If user sends "ab" â†’ 400 Bad Request
    - If user sends "a"*101 â†’ 400 Bad Request
    
    ğŸ¯ WHY SET LIMITS?
    - Database has VARCHAR(100)
    - Longer = truncated or error
    - Better to reject early!
    """
    
    full_name: Optional[str] = Field(None, max_length=255)
    """
    ğŸ“ Optional EXPLAINED:
    - Can be None/null
    - Field(None, ...) = default is None
    - User can skip this field
    """
    
    is_active: bool = Field(default=True)


class UserCreate(UserBase):
    """
    ğŸ¯ USED FOR: POST /users (create new user)
    
    Inherits from UserBase + adds password field
    """
    password: str = Field(..., min_length=8)
    """
    ğŸ” PASSWORD REQUIREMENTS:
    min_length=8: Industry minimum
    
    ğŸ“ PRODUCTION TIP:
    Add more validation with regex:
    - At least 1 uppercase
    - At least 1 number
    - At least 1 special character
    
    Field(
        ...,
        min_length=8,
        regex=r"^(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])"
    )
    """


class UserUpdate(BaseModel):
    """
    ğŸ¯ USED FOR: PATCH /users/{id} (update existing user)
    
    ALL fields optional (user updates only what they want)
    """
    email: Optional[EmailStr] = None
    username: Optional[str] = Field(None, min_length=3)
    full_name: Optional[str] = None
    is_active: Optional[bool] = None
    """
    ğŸ“ PARTIAL UPDATE PATTERN:
    
    Request: {"email": "new@example.com"}
    - Only email updates
    - Username, full_name stay same
    
    This is PATCH (partial update)
    vs PUT (replace entire resource)
    """


class UserResponse(UserBase):
    """
    ğŸ¯ USED FOR: API responses (what users see)
    
    ğŸš¨ CRITICAL: Never expose sensitive fields!
    - âŒ hashed_password
    - âŒ internal IDs
    - âŒ audit fields (deleted_by, etc.)
    """
    
    model_config = ConfigDict(from_attributes=True)
    """
    ğŸ“ WHAT DOES THIS DO?
    Allows creating schema from SQLAlchemy model:
    
    user_model = User(id=1, email="test@example.com")
    user_response = UserResponse.model_validate(user_model)
    
    Without from_attributes=True â†’ Error!
    """
    
    id: int
    is_verified: bool
    is_superuser: bool
    oauth_provider: Optional[str]
    created_at: datetime
    updated_at: datetime
    last_login: Optional[datetime]
    """
    ğŸ“ RESPONSE INCLUDES:
    - Public info (id, email, username)
    - Status flags (is_verified, is_active)
    - Timestamps (created_at, updated_at)
    
    EXCLUDES:
    - hashed_password â† NEVER SEND THIS!
    """


# ============================================================================
# STEP 6: REPOSITORY PATTERN (Data Access Layer)
# ============================================================================
"""
ğŸ¤” WHY THIS MATTERS:
Mixing database queries with business logic = Spaghetti code
Separating concerns = Clean, testable, maintainable

ğŸ“– WHAT YOU'LL LEARN:
1. What is the Repository Pattern
2. Why it matters
3. How to write clean queries
"""

# FILE: app/repositories/user.py

from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Optional
from app.models.user import User

class UserRepository:
    """
    ğŸ¯ WHAT IS THIS?
    The "data access layer" - ONLY talks to database.
    
    ğŸ—ï¸ ARCHITECTURE:
    Controller (API) â†’ Service (Business Logic) â†’ Repository (Database) â†’ DB
    
    ğŸ“ WHY SEPARATE?
    
    âŒ BAD (Mixed concerns):
    @router.post("/users")
    async def create_user(user_data: UserCreate):
        # Validation
        if await db.query(User).filter(User.email == user_data.email).first():
            raise HTTPException(409, "Email exists")
        
        # Business logic
        if user_data.email.endswith("@competitor.com"):
            raise HTTPException(403, "Domain blocked")
        
        # Database
        user = User(**user_data.dict())
        db.add(user)
        await db.commit()
        
        # Side effects
        send_email(user.email)
        
        return user
    
    Problems:
    1. Can't reuse logic
    2. Can't test in isolation
    3. Hard to maintain
    4. Mixed responsibilities
    
    âœ… GOOD (Layered):
    Repository: get_by_email(), create()
    Service: validate_user(), create_user()
    Controller: Just HTTP stuff
    """
    
    def __init__(self, session: AsyncSession):
        """
        ğŸ“ DEPENDENCY INJECTION:
        - Don't create session inside repository
        - Pass it in (easier to test, more flexible)
        """
        self.session = session
    
    async def create(self, user_data: UserCreate) -> User:
        """
        Create a new user in database.
        
        ğŸ“ STEPS:
        1. Create model instance
        2. Add to session (staging area)
        3. Flush (send SQL to DB, don't commit yet)
        4. Refresh (get generated ID from DB)
        5. Return user
        """
        user = User(**user_data.model_dump())
        """
        ğŸ“ model_dump() EXPLAINED:
        UserCreate schema â†’ dict â†’ User model
        
        user_data.model_dump() = {
            "email": "test@example.com",
            "username": "testuser",
            "password": "secret123"
        }
        
        **dict unpacks it:
        User(
            email="test@example.com",
            username="testuser",
            password="secret123"
        )
        """
        
        self.session.add(user)
        """
        ğŸ“ WHAT DOES add() DO?
        Adds user to session's "pending" list.
        NOT saved to database yet!
        
        Think of it like:
        - add() = Add item to shopping cart
        - commit() = Checkout
        """
        
        await self.session.flush()
        """
        ğŸ“ FLUSH VS COMMIT:
        
        flush():
        - Sends SQL to database
        - Gets generated ID
        - Does NOT commit transaction
        - Can still rollback
        
        commit():
        - Makes changes permanent
        - Releases locks
        - Can't rollback
        
        ğŸ¤” WHY FLUSH?
        Need user.id before committing (for other operations)
        """
        
        await self.session.refresh(user)
        """
        ğŸ“ REFRESH EXPLAINED:
        Loads user from database (gets server-generated fields)
        - id (auto-increment)
        - created_at (server default)
        - updated_at (server default)
        """
        
        return user
    
    async def get_by_id(self, user_id: int) -> Optional[User]:
        """
        Find user by ID.
        
        ğŸ“ MODERN SQLALCHEMY 2.0 SYNTAX:
        """
        stmt = select(User).where(User.id == user_id)
        """
        ğŸ“ WHAT IS select()?
        Builds SQL query:
        SELECT * FROM users WHERE id = :user_id
        
        ğŸ¤” OLD WAY (SQLAlchemy 1.x):
        user = session.query(User).filter(User.id == user_id).first()
        
        NEW WAY (SQLAlchemy 2.0):
        stmt = select(User).where(User.id == user_id)
        result = await session.execute(stmt)
        user = result.scalar_one_or_none()
        
        Why change? More explicit, better async support
        """
        
        result = await self.session.execute(stmt)
        """
        ğŸ“ execute() EXPLAINED:
        Runs the SQL query against database.
        Returns "result set"
        """
        
        return result.scalar_one_or_none()
        """
        ğŸ“ RESULT METHODS:
        
        scalar_one_or_none():
        - Returns single object or None
        - Raises error if multiple rows (data integrity check)
        
        scalar_one():
        - Returns single object
        - Raises error if not found or multiple
        
        scalars().all():
        - Returns list of objects
        - Empty list if none found
        
        first():
        - Returns first row or None
        """
    
    async def get_by_email(self, email: str) -> Optional[User]:
        """Find user by email (for login)."""
        stmt = select(User).where(User.email == email)
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> tuple[List[User], int]:
        """
        Get paginated list of users.
        
        ğŸ“ PAGINATION EXPLAINED:
        
        Without pagination:
        SELECT * FROM users;
        - 1 million rows â†’ 100MB response â†’ Browser crashes!
        
        With pagination:
        SELECT * FROM users LIMIT 50 OFFSET 0;   -- Page 1
        SELECT * FROM users LIMIT 50 OFFSET 50;  -- Page 2
        SELECT * FROM users LIMIT 50 OFFSET 100; -- Page 3
        
        ğŸ¤” WHY RETURN TOTAL COUNT?
        Frontend needs to show: "Page 1 of 234"
        """
        
        # Count query
        count_stmt = select(func.count()).select_from(User)
        total = await self.session.scalar(count_stmt) or 0
        """
        ğŸ“ COUNT QUERY:
        SELECT COUNT(*) FROM users;
        
        func.count() = SQLAlchemy function
        scalar() = Get single value (the count)
        """
        
        # Data query with pagination
        stmt = (
            select(User)
            .offset(skip)
            .limit(limit)
            .order_by(User.created_at.desc())
        )
        """
        ğŸ“ QUERY BREAKDOWN:
        
        offset(skip):
        - Skip first N rows
        - Page 1: skip=0
        - Page 2: skip=50
        - Page 3: skip=100
        
        limit(limit):
        - Return at most N rows
        - Usually 10, 25, 50, or 100
        
        order_by(User.created_at.desc()):
        - Newest users first
        - desc() = descending (newest to oldest)
        - asc() = ascending (oldest to newest)
        
        ğŸš¨ PERFORMANCE WARNING:
        OFFSET on large tables is SLOW!
        OFFSET 1000000 = Database scans 1M rows
        
        Better: Cursor pagination (WHERE id > last_id)
        """
        
        result = await self.session.execute(stmt)
        users = list(result.scalars().all())
        
        return users, total
    
    async def update(self, user: User, user_data: UserUpdate) -> User:
        """
        Update user fields.
        
        ğŸ“ PARTIAL UPDATE PATTERN:
        Only update fields that were provided.
        """
        update_data = user_data.model_dump(exclude_unset=True)
        """
        ğŸ“ exclude_unset=True:
        Only includes fields that were explicitly set.
        
        Request: {"email": "new@example.com"}
        
        Without exclude_unset:
        {"email": "new@example.com", "username": None, "full_name": None}
        â†’ Would set username and full_name to None!
        
        With exclude_unset:
        {"email": "new@example.com"}
        â†’ Only updates email
        """
        
        for field, value in update_data.items():
            setattr(user, field, value)
        """
        ğŸ“ setattr() EXPLAINED:
        Dynamic attribute setting:
        
        setattr(user, "email", "new@example.com")
        = user.email = "new@example.com"
        
        Why not direct assignment?
        Don't know field names at runtime!
        """
        
        await self.session.flush()
        await self.session.refresh(user)
        return user
    
    async def delete(self, user: User) -> None:
        """
        Delete user from database.
        
        ğŸ“ HARD DELETE:
        Actually removes row from database.
        
        âš ï¸ CONSIDERATION:
        Better to use "soft delete":
        - Set is_deleted = True
        - Keep row in database
        - Can restore later
        - Maintains audit trail
        """
        await self.session.delete(user)
        await self.session.flush()


# ============================================================================
# STEP 7: SERVICE LAYER (Business Logic)
# ============================================================================
"""
ğŸ¤” WHY THIS MATTERS:
Business logic in controllers = Tight coupling, hard to test
Business logic in services = Reusable, testable, maintainable

ğŸ“– WHAT YOU'LL LEARN:
1. What is business logic
2. Service layer pattern
3. Transaction management
4. Error handling
"""

# FILE: app/services/user.py

from app.repositories.user import UserRepository
from app.schemas.user import UserCreate, UserUpdate, UserResponse
from app.core.exceptions import NotFoundException, ConflictException

class UserService:
    """
    ğŸ¯ BUSINESS LOGIC LAYER:
    - Validates business rules
    - Coordinates multiple repositories
    - Manages transactions
    - Triggers side effects (emails, events)
    
    ğŸ—ï¸ RESPONSIBILITIES:
    Repository: "How to get data"
    Service: "What to do with data"
    Controller: "How to expose via HTTP"
    """
    
    def __init__(self, session: AsyncSession):
        self.repository = UserRepository(session)
        self.session = session
    
    async def create_user(self, user_data: UserCreate) -> UserResponse:
        """
        Create user with business validation.
        
        ğŸ“ BUSINESS RULES:
        1. Email must be unique
        2. Username must be unique
        3. Send welcome email (side effect)
        4. Log event (audit trail)
        """
        
        # Business Rule 1: Check email uniqueness
        existing = await self.repository.get_by_email(user_data.email)
        if existing:
            raise ConflictException(f"Email '{user_data.email}' already registered")
        """
        ğŸ“ WHY CHECK HERE?
        Database has UNIQUE constraint, but:
        1. Better error message (user-friendly)
        2. Fail fast (before creating user object)
        3. Can add more complex validation
        
        Example complex rule:
        if user_data.email.endswith("@competitor.com"):
            raise ValidationException("Domain not allowed")
        """
        
        # Business Rule 2: Check username uniqueness
        existing = await self.repository.get_by_username(user_data.username)
        if existing:
            raise ConflictException(f"Username '{user_data.username}' already taken")
        
        # Create user (delegates to repository)
        user = await self.repository.create(user_data)
        
        # Side effect: Send welcome email
        from app.tasks.email_tasks import send_welcome_email
        send_welcome_email.delay(user.email, user.username)
        """
        ğŸ“ .delay() EXPLAINED:
        Celery method to run task in background.
        
        Without .delay():
        send_welcome_email(user.email, user.username)
        â†’ Runs NOW (blocks for 2-5 seconds)
        
        With .delay():
        send_welcome_email.delay(user.email, user.username)
        â†’ Returns instantly (Celery worker handles it)
        """
        
        # Log event
        logger.info("User created", user_id=user.id, email=user.email)
        
        return UserResponse.model_validate(user)
        """
        ğŸ“ WHY CONVERT TO SCHEMA?
        
        user = User model (database object)
        UserResponse = API schema (what client sees)
        
        model_validate():
        - Picks only fields defined in UserResponse
        - Excludes hashed_password, internal fields
        - Validates data types
        - Converts to JSON-serializable format
        """
    
    async def get_user(self, user_id: int) -> UserResponse:
        """Get user by ID with error handling."""
        user = await self.repository.get_by_id(user_id)
        
        if not user:
            raise NotFoundException("User", user_id)
        """
        ğŸ“ CUSTOM EXCEPTIONS:
        
        NotFoundException:
        - Inherits from our BaseAppException
        - Status code: 404
        - Consistent error format
        - Centralized error handling
        
        vs raising HTTPException directly:
        - Couples service to FastAPI
        - Can't reuse service in CLI/workers
        - Harder to test
        """
        
        return UserResponse.model_validate(user)
    
    async def list_users(
        self,
        page: int = 1,
        page_size: int = 50
    ) -> dict:
        """
        List users with pagination.
        
        ğŸ“ PAGINATION LOGIC:
        page=1, page_size=50 â†’ skip=0, limit=50
        page=2, page_size=50 â†’ skip=50, limit=50
        page=3, page_size=50 â†’ skip=100, limit=50
        """
        skip = (page - 1) * page_size
        users, total = await self.repository.get_all(skip, page_size)
        
        total_pages = (total + page_size - 1) // page_size
        """
        ğŸ“ CEILING DIVISION:
        Normal: 105 / 50 = 2.1 â†’ 2 pages (loses 5 users!)
        Ceiling: (105 + 50 - 1) // 50 = 3 pages (correct!)
        
        Or use: math.ceil(total / page_size)
        """
        
        return {
            "items": [UserResponse.model_validate(u) for u in users],
            "total": total,
            "page": page,
            "page_size": page_size,
            "total_pages": total_pages
        }


# ============================================================================
# STEP 8: AUTHENTICATION SYSTEM (CRITICAL!)
# ============================================================================
"""
ğŸ¤” WHY THIS MATTERS:
Bad auth = Hacked users, stolen data, lawsuits
Good auth = Secure, scalable, standard

ğŸ“– WHAT YOU'LL LEARN:
1. Password hashing (bcrypt)
2. JWT tokens
3. OAuth2 flow
4. Security best practices
"""

# FILE: app/core/security.py

from datetime import datetime, timedelta
from jose import jwt
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    """
    Hash password using bcrypt.
    
    ğŸ“ WHY BCRYPT?
    
    âŒ BAD: Plain text
    password = "secret123"
    Problem: Database leak = All passwords stolen
    
    âŒ BAD: MD5/SHA1
    password = md5("secret123") = "5ebe2294ecd0e0f08eab7690d2a6ee69"
    Problems:
    1. Too fast (GPU cracks billions/second)
    2. Same password = same hash (rainbow tables)
    3. No salt
    
    âœ… GOOD: Bcrypt
    password = bcrypt("secret123") = "$2b$12$KIXm1Z..."
    
    Benefits:
    1. SLOW by design (0.3 seconds per attempt)
    2. Automatic salt (same password = different hash)
    3. Adaptive (increase cost as computers get faster)
    
    ğŸ” BCRYPT BREAKDOWN:
    $2b$12$KIXm1Z...
    â”‚  â”‚  â”‚   â”‚
    â”‚  â”‚  â”‚   â””â”€ Hash (184 bits)
    â”‚  â”‚  â””â”€â”€â”€â”€â”€ Salt (128 bits)
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€ Cost factor (2^12 = 4096 iterations)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Algorithm version
    
    ğŸ“ COST FACTOR:
    12 = 4096 iterations (~300ms)
    14 = 16384 iterations (~1200ms)
    
    Attacker needs:
    - 300ms per password
    - 1B passwords to try
    - 300M seconds = 9.5 YEARS!
    """
    return pwd_context.hash(password)


def verify_password(plain: str, hashed: str) -> bool:
    """
    Verify password against hash.
    
    ğŸ“ HOW IT WORKS:
    1. Extract salt from hash
    2. Hash plain password with same salt
    3. Compare results
    
    "secret123" + salt â†’ hash â†’ Compare with stored hash
    """
    return pwd_context.verify(plain, hashed)


def create_access_token(subject: int) -> str:
    """
    Create JWT access token.
    
    ğŸ“ JWT (JSON Web Token) EXPLAINED:
    
    Structure: header.payload.signature
    
    header = {"alg": "HS256", "typ": "JWT"}
    payload = {"sub": "123", "exp": 1234567890}
    signature = HMAC-SHA256(header + payload, SECRET_KEY)
    
    ğŸ” WHY JWT?
    
    âŒ SESSION-BASED AUTH:
    1. User logs in
    2. Server creates session in Redis
    3. Returns session ID cookie
    4. Every request: Check Redis
    
    Problem: Every request hits Redis (bottleneck)
    
    âœ… JWT AUTH:
    1. User logs in
    2. Server creates JWT
    3. Returns JWT to client
    4. Every request: Verify JWT signature (NO DATABASE!)
    
    Benefit: 100x faster (no DB lookup)
    
    ğŸ“ TOKEN CONTENTS:
    {
        "sub": "123",           # Subject (user ID)
        "exp": 1704124800,      # Expiration (Unix timestamp)
        "type": "access",       # Token type
        "iat": 1704123000       # Issued at
    }
    
    ğŸš¨ SECURITY:
    - JWT is SIGNED, not ENCRYPTED
    - Anyone can read payload (don't put secrets!)
    - But only server can CREATE valid signatures
    """
    expire = datetime.utcnow() + timedelta(minutes=30)
    
    to_encode = {
        "exp": expire,
        "sub": str(subject),
        "type": "access"
    }
    
    return jwt.encode(
        to_encode,
        settings.secret_key,
        algorithm="HS256"
    )


def create_refresh_token(subject: int) -> str:
    """
    Create long-lived refresh token.
    
    ğŸ“ ACCESS VS REFRESH TOKENS:
    
    Access Token:
    - Short-lived (30 min)
    - Used for API requests
    - If stolen: Limited damage
    
    Refresh Token:
    - Long-lived (7 days)
    - Used to get new access tokens
    - Stored securely (httpOnly cookie)
    
    ğŸ”„ FLOW:
    1. Login â†’ Get both tokens
    2. Use access token for API
    3. Access token expires after 30 min
    4. Use refresh token to get new access token
    5. Continue using API
    
    ğŸ¯ BENEFIT:
    - User doesn't re-login every 30 min (good UX)
    - If access token stolen: Only 30 min of access
    - Can revoke refresh tokens (store in database)
    """
    expire = datetime.utcnow() + timedelta(days=7)
    
    to_encode = {
        "exp": expire,
        "sub": str(subject),
        "type": "refresh"
    }
    
    return jwt.encode(to_encode, settings.secret_key, algorithm="HS256")


# ============================================================================
# STEP 9: API ENDPOINTS (The Interface)
# ============================================================================
"""
ğŸ¤” WHY THIS MATTERS:
Controllers are your API's face. Good design = Happy developers using your API
Bad design = Frustrated developers, support tickets

ğŸ“– WHAT YOU'LL LEARN:
1. RESTful API design
2. Dependency injection
3. Status codes
4. Request/response handling
"""

# FILE: app/api/v1/endpoints/users.py

from fastapi import APIRouter, Depends, status, HTTPException
from app.core.database import get_db
from app.core.auth_dependencies import get_current_user
from app.services.user import UserService

router = APIRouter(prefix="/users", tags=["users"])
"""
ğŸ“ ROUTER SETUP:
- prefix="/users": All routes start with /users
- tags=["users"]: Groups in API docs

Generates:
- POST /users
- GET /users/{id}
- GET /users
- etc.
"""

@router.post("", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db)
):
    """
    Create new user.
    
    ğŸ“ ENDPOINT ANATOMY:
    
    @router.post(""):
    - HTTP method: POST
    - Path: "" (= /users because of router prefix)
    
    response_model=UserResponse:
    - Validates response matches schema
    - Auto-generates response docs
    - Filters fields (removes hashed_password)
    
    status_code=201:
    - 201 = Created (successful resource creation)
    - vs 200 = OK (general success)
    
    user_data: UserCreate:
    - FastAPI automatically:
      1. Parses JSON body
      2. Validates with Pydantic
      3. Returns 422 if invalid
    
    db: AsyncSession = Depends(get_db):
    - Dependency injection
    - FastAPI calls get_db()
    - Passes result to this function
    - Automatic cleanup after request
    
    ğŸ“ HTTP STATUS CODES GUIDE:
    200 OK - Success (GET, PATCH, DELETE)
    201 Created - Resource created (POST)
    204 No Content - Success with no body (DELETE)
    400 Bad Request - Invalid input
    401 Unauthorized - Not authenticated
    403 Forbidden - Authenticated but no permission
    404 Not Found - Resource doesn't exist
    409 Conflict - Duplicate resource
    422 Unprocessable Entity - Validation failed
    500 Internal Server Error - Server bug
    """
    service = UserService(db)
    return await service.create_user(user_data)


@router.get("/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get user by ID (authenticated users only).
    
    ğŸ“ PATH PARAMETERS:
    /{user_id}:
    - GET /users/123 â†’ user_id = 123
    - FastAPI automatically converts to int
    - If not int â†’ 422 error
    
    current_user: User = Depends(get_current_user):
    - AUTHENTICATION CHECK
    - get_current_user():
      1. Extracts JWT from Authorization header
      2. Verifies signature
      3. Loads user from database
      4. Returns user or raises 401
    
    ğŸ“ IF NOT AUTHENTICATED:
    No Authorization header â†’ 401 Unauthorized
    Invalid token â†’ 401 Unauthorized
    Expired token â†’ 401 Unauthorized
    """
    service = UserService(db)
    return await service.get_user(user_id)


@router.get("", response_model=dict)
async def list_users(
    page: int = Query(default=1, ge=1),
    page_size: int = Query(default=50, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    List users with pagination.
    
    ğŸ“ QUERY PARAMETERS:
    page: int = Query(default=1, ge=1)
    
    GET /users?page=2&page_size=25
    - page = 2
    - page_size = 25
    
    Query(...) validation:
    - default=1: If not provided
    - ge=1: Greater than or equal to 1
    - le=100: Less than or equal to 100
    
    Invalid: GET /users?page=0 â†’ 422 (ge=1 violated)
    Invalid: GET /users?page_size=1000 â†’ 422 (le=100 violated)
    """
    service = UserService(db)
    return await service.list_users(page, page_size)


# ============================================================================
# COMPLETE FLOW EXAMPLE
# ============================================================================
"""
ğŸ“ LET'S TRACE A COMPLETE REQUEST:

REQUEST: POST /users
BODY: {"email": "john@example.com", "username": "john", "password": "secret123"}

1ï¸âƒ£ FASTAPI RECEIVES REQUEST
   - Routes to create_user() endpoint

2ï¸âƒ£ DEPENDENCY INJECTION
   - Calls get_db() â†’ Creates database session
   - Passes session to endpoint

3ï¸âƒ£ REQUEST VALIDATION
   - FastAPI parses JSON
   - Creates UserCreate schema
   - Validates:
     âœ… email is valid email format
     âœ… username is 3-100 chars
     âœ… password is at least 8 chars
   - If invalid â†’ Returns 422 with error details

4ï¸âƒ£ CONTROLLER LAYER (Endpoint)
   - Creates UserService(db)
   - Calls service.create_user(user_data)

5ï¸âƒ£ SERVICE LAYER (Business Logic)
   - Checks if email exists â†’ repository.get_by_email()
   - Checks if username exists â†’ repository.get_by_username()
   - If exists â†’ Raises ConflictException (409)
   - Calls repository.create(user_data)
   - Triggers side effect: send_welcome_email.delay()
   - Logs event
   - Returns UserResponse

6ï¸âƒ£ REPOSITORY LAYER (Database)
   - Creates User model instance
   - session.add(user)
   - session.flush() â†’ INSERT INTO users ...
   - session.refresh(user) â†’ Gets generated ID
   - Returns user model

7ï¸âƒ£ RESPONSE SERIALIZATION
   - UserResponse.model_validate(user)
   - Converts model â†’ schema
   - Excludes hashed_password
   - Converts datetime â†’ ISO string

8ï¸âƒ£ FASTAPI SENDS RESPONSE
   - Status: 201 Created
   - Body: {
       "id": 1,
       "email": "john@example.com",
       "username": "john",
       "created_at": "2025-01-03T10:30:00Z",
       ...
     }

9ï¸âƒ£ CLEANUP
   - get_db() context manager closes session
   - Returns connection to pool

ğŸ”Ÿ BACKGROUND TASK
   - Celery worker picks up send_welcome_email task
   - Sends email asynchronously
   - User already got response (didn't wait!)

â±ï¸ TIMING:
- Without background tasks: 2-5 seconds (waiting for email)
- With background tasks: 50-200ms (instant response)

TOTAL: ~100ms for user, email sends in background!
"""

"""
ğŸ¯